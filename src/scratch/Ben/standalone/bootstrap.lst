GAS LISTING bootstrap.s 			page 1


   1              	# 1 "bootstrap.S"
   1              	/*
   0              	
   0              	
   2              	** SCCS ID:	@(#)bootstrap.S	1.7	01/29/11
   3              	**
   4              	** File:	bootstrap.S
   5              	**
   6              	** Author:	Jon Coles
   7              	**		copyleft 1999 Jon Coles
   8              	**
   9              	** Contributor:	Warren R. Carithers, K. Reek, Garrett C. Smith
  10              	**
  11              	** Description:	Bootstrap routine.
  12              	**
  13              	** This bootstrap program is loaded by the PC BIOS into memory at
  14              	** location 0000:7C00.  It must be exactly 512 bytes long, and must
  15              	** end with the hex sequence AA55 at location 1FE.
  16              	**
  17              	** The bootstrap initially sets up a stack in low memory.  Next, it
  18              	** loads a second sector at 0000:7E00 (immediately following the
  19              	** boot block).  Then it loads the target program at TARGET_ADDRESS, 
  20              	** switches to protected mode, and branches to the target program.
  21              	**
  22              	** NOTE: This loader does NOT zero out the bss of any of the loaded
  23              	** programs.  However, a reset appears to set all memory locations
  24              	** between 0x10000 and 0x45d50 to 0, so there is no need to explicitly
  25              	** zero the bss in modules loaded into that range.
  26              	**
  27              	** Must assemble this as 16-bit code.
  28              	*/
  29              		.code16
  30              	
  31              	#include "bootstrap.h"
   1              	/*
  32              	
  33              	BOOT_SEGMENT	= 0x07C0	/* default BIOS addr to load boot sector */
  34              	BOOT_ADDRESS 	= 0x00007C00
  35              	START_SEGMENT	= 0x0000	/* where we'll put the startup code */
  36              	START_OFFSET	= 0x00007E00
  37              	VESA_OFFSET     = 0x00008000
  38              	SECTOR_SIZE	= 0x200		/* typical sector size for floppy & HD */
  39              	OFFSET_LIMIT	= 65536 - SECTOR_SIZE
  40              	
  41              	/*
  42              	** Symbol for locating the beginning of the code.
  43              	*/
  44              		.globl begtext
  45              	
  46              		.text
  47              	begtext:
  48              	
  49              	/*
  50              	** Entry point.	Begin by setting up a runtime stack.
  51              	*/
  52 0000 B8C007   		movw	$BOOT_SEGMENT, %ax	/* get our data seg */
  53 0003 8ED8     		movw	%ax, %ds
GAS LISTING bootstrap.s 			page 2


  54 0005 8ED0     		movw	%ax, %ss	/* stack segment starts at BOOT_SEGMENT */
  55 0007 B80040   		movw	$0x4000, %ax	/* and the stack starts 0x4000 beyond that */
  56 000a 89C4     		movw	%ax, %sp
  57              	
  58              	/*
  59              	** Next, verify that the disk is there and working.
  60              	*/
  61 000c B401     		movb	$0x01, %ah	/* test the disk status and make sure */
  62 000e 8A16FC01 		movb	drive, %dl	/* it's safe to proceed */
  63 0012 CD13     		int	$0x13
  64 0014 7308     		jnc	diskok
  65              	
  66 0016 BE6C01   		movw	$err_diskstatus, %si /* Something went wrong; print a message */
  67 0019 E8EF00   		call	dispMsg		/* and freeze. */
  68 001c EBFE     		jmp	.
  69              	
  70              	diskok:
  71 001e B80000   		movw	$0,%ax		/* Reset the disk */
  72 0021 8A16FC01 		movb	drive,%dl
  73 0025 CD13     		int	$0x13
  74              	
  75              		/* get drive parameters to determine number of heads and sectors/track */
  76 0027 31C0     		xorw	%ax, %ax	/* set ES:DI = 0000:0000 in case of BIOS bugs */
  77 0029 8EC0     		movw	%ax, %es
  78 002b 89C7     		movw	%ax, %di
  79 002d B408     		movb	$0x08, %ah	/* get drive parameters */
  80 002f 8A16FC01 		movb	drive, %dl	/* hard disk or floppy */
  81 0033 CD13     		int	$0x13
  82              	
  83              		/* store (max + 1) - CL[5:0] = maximum head, DH = maximum head */
  84 0035 80E13F   		andb	$0x3F, %cl
  85 0038 FEC1     		incb	%cl
  86 003a FEC6     		incb	%dh
  87              	
  88 003c 880E5801 		movb	%cl, max_sec
  89 0040 88365901 		movb	%dh, max_head
  90              	
  91              	/*
  92              	** The disk is OK, so we now need to load the second page of the bootstrap.
  93              	** It must immediately follow the boot sector on the disk,
  94              	** and the target program(s) must immediately follow.
  95              	*/
  96 0044 BE5A01   		movw	$msg_loading,%si /* Print the Loading message */
  97 0047 E8C100   		call	dispMsg
  98              	
  99 004a B80100   		movw	$1,%ax		/* sector count = 1 */
 100 004d BB0000   		movw	$START_SEGMENT,%bx /* read this into memory that */
 101 0050 8EC3     		movw	%bx,%es		/* immediately follows this code. */
 102 0052 BB007E   		movw	$START_OFFSET,%bx
 103 0055 E82E00   		call	readprog
 104              	
 105              	/*
 106              	** We've got the second block of the bootstrap program in memory. Now
 107              	** read all of the user's program blocks.  Use %di to point to the
 108              	** count field for the next block to load.
 109              	*/
 110 0058 BFFE03   		movw	$firstcount,%di
GAS LISTING bootstrap.s 			page 3


 111              	
 112 005b 1E       		pushw	%ds
 113 005c 8B1D     		movw	(%di), %bx
 114 005e B8D002   		movw	$MMAP_SEGMENT, %ax
 115 0061 8ED8     		movw	%ax, %ds
 116 0063 891E0A00 		movw	%bx, MMAP_SECTORS	/* store kernel image size */
 117 0067 1F       		popw	%ds
 118              	
 119              	nextblock:
 120 0068 8B05     		movw	(%di),%ax	/* get the # of sectors */
 121 006a 85C0     		testw	%ax,%ax		/* is it zero? */
 122 006c 0F849200 		jz	done_loading	/*   yes, nothing more to load. */
 123              	
 124 0070 83EF02   		subw	$2,%di
 125 0073 8B1D     		movw	(%di),%bx	/* get the segment value */
 126 0075 8EC3     		movw	%bx,%es		/*   and copy it to %es */
 127 0077 83EF02   		subw	$2,%di
 128 007a 8B1D     		movw	(%di),%bx	/* get the address offset */
 129 007c 83EF02   		subw	$2,%di
 130 007f 57       		pushw	%di		/* save di */
 131 0080 E80300   		call	readprog	/* read this program block, */
 132 0083 5F       		popw	%di		/* and restore di */
 133 0084 EBE2     		jmp	nextblock	/*   then go back and read the next one. */
 134              	
 135              	/*
 136              	** Read one complete program block into memory.
 137              	**
 138              	**	ax: number of sectors to read
 139              	**	es:bx = starting address for the block
 140              	*/
 141              	readprog:
 142 0086 50       		pushw	%ax		/* save sector count */
 143              	
 144 0087 B90300   		movw	$3,%cx		/* initial retry count is 3 */
 145              	retry:
 146 008a 51       		pushw	%cx		/* push the retry count on the stack. */
 147              	
 148 008b 8B0E5401 		movw	sec,%cx		/* get sector number */
 149 008f 8B165601 		movw	head,%dx	/* get head number */
 150 0093 8A16FC01 		movb	drive, %dl
 151              	
 152 0097 B80102   		movw	$0x0201,%ax	/* read 1 sector */
 153 009a CD13     		int	$0x13
 154 009c 7311     		jnc	readcont	/* jmp if it worked ok */
 155              	
 156 009e BE7E01   		movw	$err_diskread,%si /* report the error */
 157 00a1 E86700   		call	dispMsg
 158 00a4 59       		popw	%cx		/* get the retry count back */
 159 00a5 E2E3     		loop	retry		/*   and go try again. */
 160 00a7 BE9601   		movw	$err_diskfail,%si /* can't proceed, */
 161 00aa E85E00   		call	dispMsg		/* print message and freeze. */
 162 00ad EBFE     		jmp	.
 163              	
 164              	readcont:
 165 00af BE6201   		movw	$msg_dot,%si	/* print status: a dot */
 166 00b2 E85600   		call	dispMsg
 167 00b5 81FB00FE 		cmpw	$OFFSET_LIMIT,%bx  /* have we reached the offset limit? */
GAS LISTING bootstrap.s 			page 4


 168 00b9 7406     		je	adjust		/* Yes--must adjust the es register */
 169 00bb 81C30002 		addw	$SECTOR_SIZE,%bx	/* No--just adjust the block size to */
 170 00bf EB0A     		jmp	readcont2	/*    the offset and continue. */
 171              	
 172              	adjust:
 173 00c1 BB0000   		movw	$0, %bx		/* start offset over again */
 174 00c4 8CC0     		movw	%es, %ax
 175 00c6 050010   		addw	$0x1000,%ax	/* move segment pointer to next chunk */
 176 00c9 8EC0     		movw	%ax, %es
 177              	
 178              	readcont2:
 179 00cb FEC1     		incb	%cl		/* not done - move to the next sector */
 180 00cd 3A0E5801 		cmpb	max_sec, %cl	/* only 18 per track - see if we need */
 181 00d1 751B     		jnz	save_sector	/* to switch heads or tracks */
 182              	
 183 00d3 B101     		movb	$1, %cl		/* reset sector number */
 184 00d5 FEC6     		incb	%dh		/* first, switch heads */
 185 00d7 3A365901 		cmpb	max_head, %dh	/* there are only two - if we've already */
 186 00db 7511     		jnz	save_sector	/* used both, we need to switch tracks */
 187              	
 188 00dd 30F6     		xorb	%dh, %dh	/* reset to head $0 */
 189 00df FEC5     		incb	%ch		/* inc track number */
 190 00e1 80FD50   		cmpb	$80, %ch	/* 80 tracks per side - have we read all? */
 191 00e4 7508     		jnz	save_sector	/* read another track */
 192              	
 193 00e6 BE8C01   		movw	$err_toobig, %si 	/* report the error */
 194 00e9 E81F00   		call	dispMsg
 195 00ec EBFE     		jmp	.		/* and freeze */
 196              	
 197              	save_sector:
 198 00ee 890E5401 		movw	%cx,sec		/* save sector number */
 199 00f2 89165601 		movw	%dx,head	/*   and head number */
 200              	
 201 00f6 58       		popw	%ax		/* discard the retry count */
 202 00f7 58       		popw	%ax		/* get the sector count from the stack */
 203 00f8 48       		decw	%ax		/*   and decrement it. */
 204 00f9 7F8B     		jg	readprog	/* If it is zero, we're done reading. */
 205              	
 206              	readdone:
 207 00fb BE6A01   		movw	$msg_bar,%si	/* print message saying this block is done */
 208 00fe E80A00   		call	dispMsg
 209 0101 C3       		ret			/* and return to the caller */
 210              	
 211              	/*
 212              	** We've loaded the whole target program into memory,
 213              	** so it's time to transfer to the startup code.
 214              	*/
 215              	done_loading:
 216 0102 BE6401   		movw	$msg_go, %si	/* last status message */
 217 0105 E80300   		call	dispMsg
 218              	
 219 0108 E9F500   		jmp	switch		/* move to the next phase */
 220              		
 221              	/*
 222              	** Support routine - display a message byte by byte to the monitor.
 223              	*/
 224              	dispMsg:	
GAS LISTING bootstrap.s 			page 5


 225 010b 50       		pushw	%ax
 226 010c 53       		pushw	%bx
 227              	repeat:
 228 010d AC       		lodsb			/* grab next character */
 229              	
 230 010e B40E     		movb	$0x0e, %ah	/* write and advance cursor */
 231 0110 BB0700   		movw	$0x07, %bx	/* page 0, white on blank, no blink */
 232 0113 08C0     		orb	%al, %al	/* AL is character to write */
 233 0115 7404     		jz	getOut		/* if we've reached the NUL, get out */
 234              	
 235 0117 CD10     		int	$0x10		/* otherwise, print and repeat */
 236 0119 EBF2     		jmp	repeat	
 237              	
 238              	getOut:				/* we're done, so return */
 239 011b 5B       		popw	%bx
 240 011c 58       		popw	%ax
 241 011d C3       		ret
 242              	
 243              	#if 0
 244              	/*
 245              	** Debugging routine.  This lives in the 1st block of the bootstrap
 246              	** so it can be called from there as well as from the 2nd block.
 247              	**
 248              	**	movw	$'x',%di	/* a single character to print */
 249              	**	movw	value,%ax	/* a 16-bit value to print in hex */
 250              	**	call	pnum
 251              	*/
 252              	pnum:
 253              		pushw	%ax
 254              		pushw	%bx
 255              		movw	%di,%ax
 256              		movb	$0xe,%ah
 257              		movw	$7,%bx
 258              		int	$0x10
 259              	
 260              		call	pdigit
 261              		call	pdigit
 262              		call	pdigit
 263              		call	pdigit
 264              	
 265              		popw	%bx
 266              		popw	%ax
 267              		ret
 268              	
 269              	pdigit:	movw	%si,%ax
 270              		shl	$4,%si
 271              		shr	$12,%ax
 272              		cmpw	$9,%ax
 273              		jle	pdd
 274              		addw	$'A'-10,%ax
 275              		jmp	prt
 276              	pdd:	addw	$'0',%ax
 277              	prt:	movb	$0xe,%ah
 278              		movw	$7,%bx
 279              		int	$0x10
 280              		ret
 281              	#endif
GAS LISTING bootstrap.s 			page 6


 282              	
 283              	/*
 284              	** Move the GDT entries from where they are to location 0000:0000
 285              	**
 286              	** As with the IDTR and GDTR loads, we need the offset for the GDT
 287              	** data from the beginning of the segment (0000:0000).
 288              	*/
 289              	move_gdt:
 290 011e 8CCE     		movw	%cs, %si
 291 0120 8EDE     		movw	%si, %ds
 292 0122 BE167F   		movw	$start_gdt + BOOT_ADDRESS, %si
 293 0125 BF5000   		movw	$GDT_SEGMENT, %di
 294 0128 8EC7     		movw	%di, %es
 295 012a 31FF     		xorw	%di, %di
 296 012c 66B92800 		movl	$gdt_len, %ecx
 296      0000
 297 0132 FC       		cld
 298 0133 F3A4     		rep	movsb
 299 0135 C3       		ret
 300              	
 301              	/*
 302              	** Determine the amount of physical memory available to the system.
 303              	*/
 304              	check_mem:
 305 0136 50       		pushw	%ax
 306 0137 1E       		pushw	%ds
 307 0138 B8D002   		movw	$MMAP_SEGMENT, %ax
 308 013b 8ED8     		movw	%ax, %ds	  /* Write relative to the memory map start */
 309 013d B801E8   		movw	$0xE801, %ax	  /* Get memory size for >64M configurations */
 310 0140 CD15     		int	$0x15
 311 0142 A30000   		movw	%ax, MMAP_EXT_LO  /* extended memory between 1M - 16M in K */
 312 0145 891E0200 		movw	%bx, MMAP_EXT_HI  /* extended memory > 16M in 64K blocks */
 313 0149 890E0400 		movw	%cx, MMAP_CFG_LO  /* configured memory between 1M - 16M in K */
 314 014d 89160600 		movw	%dx, MMAP_CFG_HI  /* configured memory > 16M in 64K blocks */
 315 0151 1F       		popw	%ds
 316 0152 58       		popw	%ax
 317 0153 C3       		ret
 318              	
 319              	/*
 320              	** DATA AREAS.
 321              	**
 322              	** Next sector number and head number to read from.
 323              	*/
 324 0154 0200     	sec:	.word	2	/* cylinder=0, sector=1 */
 325 0156 0000     	head:	.word	0	/* head=0 */
 326 0158 13       	max_sec:	.byte	19	/* up to 18 sectors per floppy track */
 327 0159 02       	max_head:	.byte	2	/* only two r/w heads per floppy drive */
 328              	
 329              	/*
 330              	** Status and error messages.
 331              	*/
 332              	msg_loading:
 333 015a 4C6F6164 		.asciz "Loading"
 333      696E6700 
 334              	msg_dot:
 335 0162 2E00     		.asciz "."
 336              	msg_go:
GAS LISTING bootstrap.s 			page 7


 337 0164 646F6E65 		.asciz "done."
 337      2E00
 338              	msg_bar:
 339 016a 7C00     		.asciz	"|"
 340              	
 341              	/*
 342              	** Error messages.
 343              	*/
 344              	err_diskstatus:
 345 016c 4469736B 		.asciz "Disk not ready.\n\r"
 345      206E6F74 
 345      20726561 
 345      64792E0A 
 345      0D00
 346              	err_diskread:
 347 017e 52656164 		.asciz "Read failed\n\r"
 347      20666169 
 347      6C65640A 
 347      0D00
 348              	err_toobig:
 349 018c 546F6F20 		.asciz	"Too big\n\r"
 349      6269670A 
 349      0D00
 350              	err_diskfail:
 351 0196 43616E27 		.asciz	"Can't proceed\n\r"
 351      74207072 
 351      6F636565 
 351      640A0D00 
 352              	
 353              	/*
 354              	** Data areas.
 355              	*/
 356              	
 357              	/*
 358              	** The GDTR and IDTR contents.
 359              	*/
 360              	gdt_48:
 361 01a6 0020     		.word	0x2000		/* 1024 GDT entries x 8 bytes/entry = 8192 */
 362 01a8 00050000 		.quad	GDT_ADDRESS
 362      00000000 
 363              	
 364              	idt_48:
 365 01b0 0008     		.word	0x0800		/* 256 interrupts */
 366 01b2 00250000 		.quad	IDT_ADDRESS
 366      00000000 
 367              	
 368              	/*
 369              	** Originally, the GDT contents were here.  When booting from a floppy
 370              	** disk, that's not a problem, as all 510 available bytes of the boot
 371              	** sector can be used.  However, when booting from a hard drive, only
 372              	** the first 446 bytes (0x000-0x1bd) can be used, and including the GDT
 373              	** here pushed this part of the bootstrap over that limit.  The older
 374              	** machines in the lab (Intel D867PERL motherboards) didn't enforce
 375              	** this when booting from a flash drive; however, the current machines
 376              	** (Intel DG41TX motherboards) do, so the GDT contents are now in the
 377              	** second sector of the bootstrap program.
 378              	*/
GAS LISTING bootstrap.s 			page 8


 379              	
 380              	/*
 381              	** End of the first sector of the boot program.  The last two bytes
 382              	** of this sector must be AA55 in order for the disk to be recognized
 383              	** by the BIOS as bootable.
 384              	*/
 385 01ba 00000000 		.org	SECTOR_SIZE-4
 385      00000000 
 385      00000000 
 385      00000000 
 385      00000000 
 386              	
 387 01fc 0000     	drive:	.word	0	/* 0x00 = floppy, 0x80 = usb */
 388              	
 389              	boot_sig:
 390 01fe 55AA     		.word 0xAA55
 391              	
 392              	/*
 393              	** Startup code.
 394              	**
 395              	** This code configures the GDT, enters protected mode, and then
 396              	** transfers to the OS entry point.
 397              	*/
 398              	
 399              	switch:
 400 0200 FA       		cli
 401 0201 B080     		movb	$0x80, %al	/* disable NMIs */
 402 0203 E670     		outb	%al, $0x70
 403              	
 404              	    #define DUMP_VESA_INFO
 405              	    #define GET_VESA_MODE 0x11A
 406              	    #define SET_VESA_MODE 0x11A
 407              	
 408 0205 E8B300   		call	floppy_off
 409              	    /* should we dump vesa information to 0x7C00 */
 410              	    #ifdef DUMP_VESA_INFO 
 411 0208 E83100   	    call    vesa_information
 412              	    #endif
 413              	    #ifdef GET_VESA_MODE
 414 020b B91A01   	    movw $GET_VESA_MODE, %cx
 415 020e E83D00   	    call get_vesa_mode
 416              	    #endif
 417              	    #ifdef SET_VESA_MODE
 418 0211 BB1A01   	    movw $SET_VESA_MODE, %bx
 419 0214 E89E00   	    call set_vesa_mode
 420              	    #endif
 421              	
 422              	    #call    find_best_vesa_mode
 423 0217 E8AA00   		call	enable_A20
 424 021a E801FF   		call	move_gdt
 425 021d E816FF   		call	check_mem
 426              	
 427              	/*
 428              	** The IDTR and GDTR are loaded relative to this segment, so we must
 429              	** use the full offsets from the beginning of the segment (0000:0000);
 430              	** however, we were loaded at 0000:7c00, so we need to add that in.
 431              	*/
GAS LISTING bootstrap.s 			page 9


 432 0220 0F011EB0 		lidt	idt_48 + BOOT_ADDRESS
 432      7D
 433 0225 0F0116A6 		lgdt	gdt_48 + BOOT_ADDRESS
 433      7D
 434              	
 435 022a 0F20C0   		movl	%cr0, %eax	/* get current CR0 */
 436 022d 6683C801 		orl	$1, %eax	/* set the PE bit */
 437 0231 0F22C0   		movl	%eax, %cr0	/* and store it back. */
 438              		
 439              		/*
 440              		** We'll be in protected mode at the start of the user's code
 441              		** right after this jump executes.
 442              		**
 443              		** First, a byte to force 32-bit mode execution, followed by
 444              		** a 32-bit long jump.  The long ("far") jump loads both EIP
 445              		** and CS with the proper values so that when we land at the
 446              		** destination address in protected mode, the next instruction
 447              		** fetch doesn't cause a fault.
 448              		**
 449              		** The old code for this:
 450              		**
 451              		**	.byte	06xx, 0xEA
 452              		**	.long	TARGET_ADDRESS
 453              		**	.word	GDT_CODE
 454              		*/
 455              	
 456 0234 66       		.byte	0x66	/* 32-bit mode prefix */
 457              		.code32
 458 0235 EA000001 		ljmp	$GDT_CODE, $TARGET_ADDRESS
 458      001000
 459              		.code16
 460              	
 461              	/**
 462              	 * @author Benjamin Mayes
 463              	 * @description: Puts VESA controller information at memory address 0x7C00
 464              	 **/ 
 465              	vesa_information:
 466 023c 06       	    push %es
 467 023d 57       	    push %di
 468 023e B8004F   	    movw $0x4f00, %ax 
 469 0241 BF0000   	    movw $0x0000, %di
 470 0244 8EC7     	    movw %di, %es
 471 0246 BF007C   	    movw $0x7C00, %di
 472 0249 CD10     	    int $0x10
 473 024b 5F       	    pop %di
 474 024c 07       	    pop %es
 475 024d C3       	    ret
 476              	
 477              	/**
 478              	 * @author Benjamin Mayes
 479              	 * @description: Puts information about the VESA mode in %cx at memory address 
 480              	 *               0x7A00
 481              	 */
 482              	get_vesa_mode:
 483 024e 51       	    push %cx
 484 024f 06       	    push %es
 485 0250 57       	    push %di
GAS LISTING bootstrap.s 			page 10


 486 0251 B8014F   	    movw $0x4f01, %ax
 487 0254 BF0000   	    movw $0x0000, %di
 488 0257 8EC7     	    movw %di, %es
 489 0259 BF007A   	    movw $0x7A00, %di
 490 025c CD10     	    int $0x10
 491 025e 5F       	    pop %di
 492 025f 07       	    pop %es
 493 0260 59       	    pop %cx
 494 0261 C3       	    ret
 495              	
 496              	find_best_vesa_mode:
 497 0262 50       	    push %ax
 498 0263 53       	    push %bx
 499 0264 51       	    push %cx
 500 0265 52       	    push %dx
 501 0266 1E       	    push %ds
 502 0267 57       	    push %di
 503              	    #move the segment into %ds
 504 0268 BB0D7C   	    movw $0x7C0D, %bx 
 505 026b 8E1F     	    movw (%bx), %ds
 506              	    #move the offset into %bx
 507 026d BB0F7C   	    movw $0x7C0F, %bx 
 508              	
 509              	    #add some stack space for temporaries
 510 0270 6A00     	    push $0
 511 0272 6A00     	    push $0
 512              	
 513              	    #begin the main loop
 514              	    fbvm_begin:
 515 0274 833FFF   	    cmpw $0xFFFF, (%bx)
 516 0277 7431     	    je fbvm_end
 517              	        #get the mode number and obtain the vesa mode struct
 518 0279 8B0F     	        movw (%bx), %cx
 519 027b E8D0FF   	        call get_vesa_mode
 520              	        #save the current data segment
 521 027e 8CDF     	        movw %ds, %di
 522              	        #zero out the data segment
 523 0280 B90000   	        movw $0, %cx
 524 0283 8ED9     	        movw %cx, %ds 
 525 0285 53       	        push %bx
 526              	
 527              	        # calculate the disirabilty of the video mode
 528 0286 BBA007   	        movw $0x7A0, %bx
 529 0289 8B5712   	        movw 18(%bx), %dx
 530 028c C1EA08   	        shrw $8, %dx
 531 028f 8B4714   	        movw 20(%bx), %ax
 532 0292 C1E808   	        shrw $8, %ax
 533 0295 F7E2     	        mul %dx
 534 0297 5B       	        pop %bx
 535              	        
 536 0298 5A       	        pop %dx
 537 0299 39C2     	        cmp %ax, %dx
 538 029b 7E05     	        jle fbvm_end_loop
 539 029d 5A       	            pop %dx #We don't want the "best" video mode on the stack anymore
 540 029e FF37     	            push (%bx) #put the new "best" mode on the stack
 541 02a0 89C2     	            movw %ax, %dx #put the best value into %dx
 542              	    fbvm_end_loop:
GAS LISTING bootstrap.s 			page 11


 543 02a2 52       	    push %dx # put dx back onto the stack
 544 02a3 8EDF     	    movw %di, %ds #restore the data semgnet
 545 02a5 83C302   	    addw $2, %bx #increment the video mode
 546 02a8 EBCA     	    jmp fbvm_begin
 547              	    fbvm_end:
 548 02aa 5B       	    pop %bx
 549 02ab 5B       	    pop %bx
 550 02ac 89D9     	    movw %bx, %cx
 551              	    #call get_vesa_mode
 552              	    #call set_vesa_mode
 553 02ae 5F       	    pop %di
 554 02af 1F       	    pop %ds
 555 02b0 5A       	    pop %dx
 556 02b1 59       	    pop %cx
 557 02b2 5B       	    pop %bx
 558 02b3 58       	    pop %ax
 559 02b4 C3       	    ret
 560              	
 561              	/**
 562              	 * @author Benjamin Mayes
 563              	 * @description Sets the VESA mode to the mode in %bx
 564              	 */
 565              	set_vesa_mode:
 566 02b5 B8024F   	    movw $0x4f02,%ax
 567 02b8 CD10     	    int $0x10
 568 02ba C3       	    ret
 569              	/*
 570              	** Supporting code.
 571              	**
 572              	** Turn off the motor on the floppy disk drive.
 573              	*/
 574              	floppy_off:
 575 02bb 52       		push	%dx
 576 02bc BAF203   		movw	$0x3f2, %dx
 577 02bf 30C0     		xorb	%al, %al
 578 02c1 EE       		outb	%al, %dx
 579 02c2 5A       		pop	%dx
 580 02c3 C3       		ret
 581              	
 582              	/*
 583              	** Enable the A20 gate for full memory access.
 584              	*/
 585              	enable_A20:
 586 02c4 E82D00   		call	a20wait
 587 02c7 B0AD     		movb	$0xad, %al
 588 02c9 E664     		outb	%al, $0x64
 589              	
 590 02cb E82600   		call	a20wait
 591 02ce B0D0     		movb	$0xd0, %al
 592 02d0 E664     		outb	%al, $0x64
 593              	
 594 02d2 E83000   		call	a20wait2
 595 02d5 E460     		inb	$0x60, %al
 596 02d7 6650     		pushl	%eax
 597              	
 598 02d9 E81800   		call	a20wait
 599 02dc B0D1     		movb	$0xd1, %al
GAS LISTING bootstrap.s 			page 12


 600 02de E664     		outb	%al, $0x64
 601              	
 602 02e0 E81100   		call	a20wait
 603 02e3 6658     		popl	%eax
 604 02e5 0C02     		orb	$2, %al
 605 02e7 E660     		outb	%al, $0x60
 606              	
 607 02e9 E80800   		call	a20wait
 608 02ec B0AE     		mov	$0xae, %al
 609 02ee E664     		out	%al, $0x64
 610              	
 611 02f0 E80100   		call	a20wait
 612 02f3 C3       		ret
 613              	
 614              	a20wait:	/* wait until bit 1 of the device register is clear */
 615 02f4 66B90000 		movl    $65536, %ecx	/* loop a lot if need be */
 615      0100
 616              	wait_loop: 
 617 02fa E464     		inb     $0x64, %al	/* grab the byte */
 618 02fc A802     		test    $2, %al		/* is the bit clear? */
 619 02fe 7404     		jz      wait_exit	/* yes */
 620 0300 E2F8     		loop    wait_loop	/* no, so loop */
 621 0302 EBF0     		jmp     a20wait		/* if still not clear, go again */
 622              	wait_exit:    
 623 0304 C3       		ret
 624              	
 625              	a20wait2:	/* like a20wait, but waits until bit 0 is set. */
 626 0305 66B90000 		mov     $65536, %ecx
 626      0100
 627              	wait2_loop:
 628 030b E464     		in      $0x64, %al
 629 030d A801     		test    $1, %al
 630 030f 7504     		jnz     wait2_exit
 631 0311 E2F8     		loop    wait2_loop
 632 0313 EBF0     		jmp     a20wait2
 633              	wait2_exit:
 634 0315 C3       		ret
 635              	
 636              	/*
 637              	** The GDT.  This cannot be created in C because the bootstrap is not
 638              	** linked with that code.
 639              	*/
 640              	start_gdt:
 641 0316 00000000 		.word	0,0,0,0		/* first GDT entry is always null */
 641      00000000 
 642              	
 643              	linear_seg:	/* limit FFFFF, base 0, R/W data seg, 32-bit 4K */
 644 031e FFFF     		.word	0xFFFF	/* limit[15:0] */
 645 0320 0000     		.word	0x0000	/* base[15:0] */
 646 0322 00       		.byte	0x00	/* base[23:16] */
 647 0323 92       		.byte	0x92	/* access byte */
 648 0324 CF       		.byte	0xCF	/* granularity */
 649 0325 00       		.byte	0x00	/* base[31:24] */
 650              	
 651              	code_seg:	/* limit FFFFF, base 0, R/E code seg, 32-bit 4K */
 652 0326 FFFF     		.word	0xFFFF
 653 0328 0000     		.word	0x0000
GAS LISTING bootstrap.s 			page 13


 654 032a 00       		.byte	0x00
 655 032b 9A       		.byte	0x9A	/* 1 00 1 1010: present, prio 0, C/D, R/E code */
 656 032c CF       		.byte	0xCF	/* 1 1 00 1111: 4K, 32-bit, 0, 0, limit[19:16] */
 657 032d 00       		.byte	0x00
 658              	
 659              	data_seg:	/* limit FFFFF, base 0, R/W data seg, 32-bit 4K */
 660 032e FFFF     		.word	0xFFFF
 661 0330 0000     		.word	0x0000
 662 0332 00       		.byte	0x00
 663 0333 92       		.byte	0x92	/* 1 00 1 0010: present, prio 0, C/D, R/W data */
 664 0334 CF       		.byte	0xCF
 665 0335 00       		.byte	0x00
 666              	
 667              	stack_seg:	/* limit FFFFF, base 0, R/W data seg, 32-bit 4K */
 668 0336 FFFF     		.word	0xFFFF
 669 0338 0000     		.word	0x0000
 670 033a 00       		.byte	0x00
 671 033b 92       		.byte	0x92
 672 033c CF       		.byte	0xCF
 673 033d 00       		.byte	0x00
 674              	
 675              	end_gdt:
 676              	gdt_len = end_gdt - start_gdt
 677              	
 678              	/*
 679              	** The end of this program will contain a list of the sizes and load
 680              	** addresses of all of the blocks to be loaded.  THese values are
 681              	** inserted here by the Modify program, which checks that there are
 682              	** not so many blocks that the IDT would be overwritten.  The layout
 683              	** of the data is:
 684              	**
 685              	**	offset
 686              	**	segment
 687              	**	# of sectors
 688              	**
 689              	** with the # of sectors for the first block appearing at firstcount, and
 690              	** the other values appearing just before it.  If additional blocks are
 691              	** to be loaded, their values appear just before the previous set.
 692              	*/
 693              	
 694 033e 00000000 		.org	1024-2
 694      00000000 
 694      00000000 
 694      00000000 
 694      00000000 
 695              	firstcount:
 696 03fe 0000     		.word	0	/* n_sectors for 1st module will go here */
GAS LISTING bootstrap.s 			page 14


DEFINED SYMBOLS
         bootstrap.S:33     *ABS*:00000000000007c0 BOOT_SEGMENT
         bootstrap.S:34     *ABS*:0000000000007c00 BOOT_ADDRESS
         bootstrap.S:35     *ABS*:0000000000000000 START_SEGMENT
         bootstrap.S:36     *ABS*:0000000000007e00 START_OFFSET
         bootstrap.S:37     *ABS*:0000000000008000 VESA_OFFSET
         bootstrap.S:38     *ABS*:0000000000000200 SECTOR_SIZE
         bootstrap.S:39     *ABS*:000000000000fe00 OFFSET_LIMIT
         bootstrap.S:47     .text:0000000000000000 begtext
         bootstrap.S:387    .text:00000000000001fc drive
         bootstrap.S:70     .text:000000000000001e diskok
         bootstrap.S:344    .text:000000000000016c err_diskstatus
         bootstrap.S:224    .text:000000000000010b dispMsg
         bootstrap.S:326    .text:0000000000000158 max_sec
         bootstrap.S:327    .text:0000000000000159 max_head
         bootstrap.S:332    .text:000000000000015a msg_loading
         bootstrap.S:141    .text:0000000000000086 readprog
         bootstrap.S:695    .text:00000000000003fe firstcount
         bootstrap.S:119    .text:0000000000000068 nextblock
         bootstrap.S:215    .text:0000000000000102 done_loading
         bootstrap.S:145    .text:000000000000008a retry
         bootstrap.S:324    .text:0000000000000154 sec
         bootstrap.S:325    .text:0000000000000156 head
         bootstrap.S:164    .text:00000000000000af readcont
         bootstrap.S:346    .text:000000000000017e err_diskread
         bootstrap.S:350    .text:0000000000000196 err_diskfail
         bootstrap.S:334    .text:0000000000000162 msg_dot
         bootstrap.S:172    .text:00000000000000c1 adjust
         bootstrap.S:178    .text:00000000000000cb readcont2
         bootstrap.S:197    .text:00000000000000ee save_sector
         bootstrap.S:348    .text:000000000000018c err_toobig
         bootstrap.S:206    .text:00000000000000fb readdone
         bootstrap.S:338    .text:000000000000016a msg_bar
         bootstrap.S:336    .text:0000000000000164 msg_go
         bootstrap.S:399    .text:0000000000000200 switch
         bootstrap.S:227    .text:000000000000010d repeat
         bootstrap.S:238    .text:000000000000011b getOut
         bootstrap.S:289    .text:000000000000011e move_gdt
         bootstrap.S:640    .text:0000000000000316 start_gdt
                            *ABS*:0000000000000028 gdt_len
         bootstrap.S:304    .text:0000000000000136 check_mem
         bootstrap.S:360    .text:00000000000001a6 gdt_48
         bootstrap.S:364    .text:00000000000001b0 idt_48
         bootstrap.S:389    .text:00000000000001fe boot_sig
         bootstrap.S:574    .text:00000000000002bb floppy_off
         bootstrap.S:465    .text:000000000000023c vesa_information
         bootstrap.S:482    .text:000000000000024e get_vesa_mode
         bootstrap.S:565    .text:00000000000002b5 set_vesa_mode
         bootstrap.S:585    .text:00000000000002c4 enable_A20
         bootstrap.S:496    .text:0000000000000262 find_best_vesa_mode
         bootstrap.S:514    .text:0000000000000274 fbvm_begin
         bootstrap.S:547    .text:00000000000002aa fbvm_end
         bootstrap.S:542    .text:00000000000002a2 fbvm_end_loop
         bootstrap.S:614    .text:00000000000002f4 a20wait
         bootstrap.S:625    .text:0000000000000305 a20wait2
         bootstrap.S:616    .text:00000000000002fa wait_loop
         bootstrap.S:622    .text:0000000000000304 wait_exit
GAS LISTING bootstrap.s 			page 15


         bootstrap.S:627    .text:000000000000030b wait2_loop
         bootstrap.S:633    .text:0000000000000315 wait2_exit
         bootstrap.S:643    .text:000000000000031e linear_seg
         bootstrap.S:651    .text:0000000000000326 code_seg
         bootstrap.S:659    .text:000000000000032e data_seg
         bootstrap.S:667    .text:0000000000000336 stack_seg
         bootstrap.S:675    .text:000000000000033e end_gdt

NO UNDEFINED SYMBOLS
